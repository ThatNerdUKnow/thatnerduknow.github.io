<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>typescript on Brandon Piña</title><link>https://thatnerduknow.github.io/tags/typescript/</link><description>Recent content in typescript on Brandon Piña</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 31 Aug 2022 17:26:00 -0500</lastBuildDate><atom:link href="https://thatnerduknow.github.io/tags/typescript/index.xml" rel="self" type="application/rss+xml"/><item><title>Typescript Is Magic</title><link>https://thatnerduknow.github.io/posts/typescript-is-magic/</link><pubDate>Wed, 31 Aug 2022 17:26:00 -0500</pubDate><guid>https://thatnerduknow.github.io/posts/typescript-is-magic/</guid><description>Typescript somehow always manages to find new and exciting ways to surprise me. It&amp;rsquo;s no secret that investing time in defining good types for your projects is well worth it as you get better intellisense and lower cognitive load when dealing with your custom types. (What properties exist on this object again?) However, sometimes it can be difficult to define a type for an upstream service, like an API. If you know what keys/types to expect beforehand you might define your types as such:</description><content>&lt;p>Typescript somehow always manages to find new and exciting ways to surprise me. It&amp;rsquo;s no secret that investing time in defining good types for your projects is well worth it as you get better intellisense and lower cognitive load when dealing with your custom types. (&lt;em>What properties exist on this object again?&lt;/em>) However, sometimes it can be difficult to define a type for an upstream service, like an API. If you know what keys/types to expect beforehand you might define your types as such:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">APIResponse&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">data&lt;/span>: &lt;span style="color:#66d9ef">APIData&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">APIError&lt;/span>; &lt;span style="color:#75715e">// Data returned by the api could be valid or not
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">headers&lt;/span>: &lt;span style="color:#66d9ef">Record&lt;/span>&amp;lt;&lt;span style="color:#f92672">string&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span> &lt;span style="color:#a6e22e">string&lt;/span>&amp;gt;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">timestamp&lt;/span>: &lt;span style="color:#66d9ef">Date&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">motd&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Therefore we need to know what properties to expect
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">APIData&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">foo&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;bar&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">APIError&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">message&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;You done goofed&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="the-problem">The problem&lt;/h2>
&lt;p>But what if you don&amp;rsquo;t know what keys exist at build time? Like in the case an api batch endpoint or a configuration file? What if certain key patterns map to certain types? Enter &lt;em>&lt;strong>Template Literals&lt;/strong>&lt;/em> and &lt;em>&lt;strong>Intersection types&lt;/strong>&lt;/em>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Define individual record types with a key matching a pattern
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// defined by a template literal and the corresponding type
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">stringRecord&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Record&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#e6db74">`String&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#66d9ef">number&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>,&lt;span style="color:#66d9ef">string&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#75715e">// Properties with keys matching &amp;#34;String${number}&amp;#34; will be of type string
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">numberRecord&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">Record&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#e6db74">`Number&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#66d9ef">number&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>,&lt;span style="color:#66d9ef">number&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#75715e">// Properties with keys matching &amp;#34;Number${number}&amp;#34; will be of type number
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// An intersection type rather than a union type is necessary
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Because the record types need to coexist
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// rather than being of one type or the other
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">intersectionRecord&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">stringRecord&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#a6e22e">numberRecord&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>: &lt;span style="color:#66d9ef">intersectionRecord&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">foo&lt;/span>[&lt;span style="color:#e6db74">`String&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Bar&amp;#34;&lt;/span> &lt;span style="color:#75715e">// Valid
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">foo&lt;/span>[&lt;span style="color:#e6db74">`Number&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#75715e">// Also Valid
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here&amp;rsquo;s where things get interesting. &lt;em>Typescript can warn us of invalid uses of our type&lt;/em> on both our keys and values of the record.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Invalid assignment to valid key
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">foo&lt;/span>[&lt;span style="color:#e6db74">`Number&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Baz&amp;#34;&lt;/span> &lt;span style="color:#75715e">// Type &amp;#39;string&amp;#39; is not assignable to type &amp;#39;number&amp;#39;.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">foo&lt;/span>[&lt;span style="color:#e6db74">`String&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#75715e">// Type &amp;#39;number&amp;#39; is not assignable to type &amp;#39;string&amp;#39;.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Assignment to invalid key
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">foo&lt;/span>[&lt;span style="color:#e6db74">`NumberA`&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#75715e">// Property &amp;#39;NumberA&amp;#39; does not exist on type &amp;#39;intersectionRecord&amp;#39;.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">foo&lt;/span>[&lt;span style="color:#e6db74">`StringA`&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Foo&amp;#34;&lt;/span> &lt;span style="color:#75715e">// Property &amp;#39;StringA&amp;#39; does not exist on type &amp;#39;intersectionRecord&amp;#39;.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">foo&lt;/span>[&lt;span style="color:#e6db74">`Invalid Key`&lt;/span>] &lt;span style="color:#75715e">// Property &amp;#39;Invalid Key&amp;#39; does not exist on type &amp;#39;intersectionRecord&amp;#39;.
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="okay-so-what">Okay, so what?&lt;/h2>
&lt;p>Imagine if you will our api provides us a batch endpoint which we may make multiple requests and make subsequent requests based on other requests in the batch. We may request different &lt;em>&lt;strong>types&lt;/strong>&lt;/em> of resources and a single union type record: &lt;code>Record&amp;lt;string, ResourceA|ResourceB|etc.&amp;gt;&lt;/code> type may not be suitable for our needs. If we can derive the type we expect from the &lt;em>&lt;strong>key&lt;/strong>&lt;/em> of the object instead of using a union type record, we can provide an extra level of type safety!&lt;/p>
&lt;h2 id="tldr">TLDR&lt;/h2>
&lt;p>Using &lt;em>Intersection Types&lt;/em> and &lt;em>Template Literals&lt;/em> in a record type allows us to derive an object&amp;rsquo;s type based off of it&amp;rsquo;s key. This is especially useful when you don&amp;rsquo;t know how many keys may exist on this object at build time with the caveat that the keys must follow a predictable pattern&lt;/p></content></item></channel></rss>