<!doctype html><html lang=en><head><title>Making an Enigma Machine :: Brandon Piña</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Using the rust programming language, I create a multi-threaded CLI app that emulates an Enigma Machine that's way faster than it needs to be"><meta name=keywords content="rust,project,programming"><meta name=robots content="noodp"><link rel=canonical href=https://thatnerduknow.github.io/posts/enigma-machine/><link rel=stylesheet href=https://thatnerduknow.github.io/assets/style.css><link rel=stylesheet href=https://thatnerduknow.github.io/assets/green.css><link rel=apple-touch-icon href=https://thatnerduknow.github.io/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://thatnerduknow.github.io/img/favicon/green.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Making an Enigma Machine"><meta property="og:description" content="Using the rust programming language, I create a multi-threaded CLI app that emulates an Enigma Machine that's way faster than it needs to be"><meta property="og:url" content="https://thatnerduknow.github.io/posts/enigma-machine/"><meta property="og:site_name" content="Brandon Piña"><meta property="og:image" content="https://thatnerduknow.github.io/"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2022-10-24 16:53:41 -0500 -0500"></head><body class=green><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=https://thatnerduknow.github.io/><div class=logo>Terminal</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/tags/>Tags</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/tags/>Tags</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://thatnerduknow.github.io/posts/enigma-machine/>Making an Enigma Machine</a></h1><div class=post-meta><span class=post-date>2022-10-24
[Updated: 2022-10-24]</span>
<span class=post-author>:: Brandon Piña</span>
<span class=post-reading-time>:: 15 min read (3175 words)</span></div><span class=post-tags>#<a href=https://thatnerduknow.github.io/tags/rust/>rust</a>&nbsp;
#<a href=https://thatnerduknow.github.io/tags/project/>project</a>&nbsp;
#<a href=https://thatnerduknow.github.io/tags/programming/>programming</a>&nbsp;</span><div class=table-of-contents><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#whats-an-enigma-machine>What&rsquo;s an Enigma Machine?</a></li><li><a href=#how-does-it-work>How does it work?</a></li><li><a href=#lets-get-rusty>Let&rsquo;s get rusty</a><ul><li><a href=#the-cipher-newtype>The Cipher newtype</a></li><li><a href=#the-character-and-position-newtypes>The Character and Position newtypes</a></li><li><a href=#the-rotor-struct>The Rotor Struct</a></li><li><a href=#the-reflector>The Reflector</a></li><li><a href=#the-plugboard>The plugboard</a></li><li><a href=#putting-it-together-enigma>Putting it together: Enigma</a></li></ul></li><li><a href=#the-benchmarks>The Benchmarks:</a></li></ul></nav></div><div class=post-content><div><h2 id=whats-an-enigma-machine>What&rsquo;s an Enigma Machine?<a href=#whats-an-enigma-machine class=hanchor arialabel=Anchor>&#8983;</a></h2><blockquote><p>The Enigma machine is a cipher device developed and used in the early- to mid-20th century to protect commercial, diplomatic, and military communication. It was employed extensively by Nazi Germany during World War II, in all branches of the German military. The Enigma machine was considered so secure that it was used to encipher the most top-secret messages. &ndash; Wikipedia</p></blockquote><h2 id=how-does-it-work>How does it work?<a href=#how-does-it-work class=hanchor arialabel=Anchor>&#8983;</a></h2><p>The Enigma machine is comprised of 3 components:</p><ul><li>The Rotor Mechanism comprised of 3 rotors from a set of Five originally but more rotor variants were added later</li><li>A Reflector</li><li>A plugboard</li></ul><p>Each component effectively works as a <em><strong>Substitution Cipher</strong></em> or <em><strong>Caesar Cipher</strong></em>. It&rsquo;s one of the simplest ciphers there is, Simply put, each character is substituted with another character and no characters map to themselves (because that would render the cipher pointless); Think of Caesar Ciphers as those secret decoder ring toys you give to kids so that they can pretend that they&rsquo;re spies.</p><p>Now if the Enigma machine is implemented using simple Caesar Ciphers, what made it so tough to crack? The answer lies in the rotor mechanism. Every time a character is encoded through the machine, the first rotor advances in position, and in certain positions there are notches, which allow the next rotor in the sequence to advance. The machine&rsquo;s configuration changes as you type! What this means in practice is that if You were to encode the same character multiple times you would get different characters every time.</p><p>A property of the enigma machine, Enabled by use of the reflector allows messages encoded by the machine for a given configuration to also be decoded by the machine. If you know the configuration of the machine for an encoded message, you can decode the ciphertext and get the original plaintext back</p><h2 id=lets-get-rusty>Let&rsquo;s get rusty<a href=#lets-get-rusty class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Feel free to skip this part, I get very detailed here</p><h3 id=the-cipher-newtype>The Cipher newtype<a href=#the-cipher-newtype class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Since every component is implemented as a Caesar Cipher, it makes sense to start creating a type that each of our components can use internally, so that we don&rsquo;t have to re-write encoding and decoding logic. The perfect underlying structure for a caesar cipher is a HashMap, or rather, a <em>bidirectional</em> HashMap because the mapping relationship between characters goes both ways</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Cipher</span>(
</span></span><span style=display:flex><span>    HashMap<span style=color:#f92672>&lt;</span>Character, Character, BuildNoHashHasher<span style=color:#f92672>&lt;</span>Character<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>    HashMap<span style=color:#f92672>&lt;</span>Character, Character, BuildNoHashHasher<span style=color:#f92672>&lt;</span>Character<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>As you can see, I implemented the <code>Cipher</code> struct as a newtype over a tuple of HashMaps; one for each side of the mapping relationship. I feel as if I should explain what&rsquo;s going on in the type arguments here. The first type argument for HashMap is the type for the <strong>Key</strong> and the second type argument is the type for the <strong>Value</strong>. The third argument is a bit special. Internally HashMaps in rust use a cryptographically secure hashing function to generate hashes for its keys. The reason for this is to prevent DOS attacks against the hash. This is fine and all, but it&rsquo;s rather slow for our purposes. Fortunately for us, HashMap allows us to replace the Hashing Function that it uses internally. Since the data we&rsquo;re storing in this hashmap isn&rsquo;t terribly important and the data inside the <code>Character</code> newtype (more on that later) is a simple char we can use the <code>NoHash</code> hashing function. NoHash does exactly what it sounds like, Nothing. If my understanding is correct, it uses the bitwise representation of the value itself as its key. Since it&rsquo;s not doing very much work under the hood, this makes the hashing function much, much faster. While this is much faster than using the original hashing function, It was only marginally (2%) faster than the original implementation which used a Vector Internally. I would say the reason for this is likely because <em>n</em> is small and the relatively expensive operation of decoding is the only place where we would have seen a speed-up and that only happens three times per Character in the entire machine.</p><p>The Cipher type includes a bit of validation inside the constructor</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> FromStr <span style=color:#66d9ef>for</span> Cipher {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> Err <span style=color:#f92672>=</span> Bruh;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from_str</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Self, Self::Err<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Convert each char in the string slice into the Character newtype
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Ensuring that the only characters inside the provided string are
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// A-Z
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> res: Vec<span style=color:#f92672>&lt;</span>Character<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> s
</span></span><span style=display:flex><span>            .chars()
</span></span><span style=display:flex><span>            .into_iter()
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> Character::try_from(c))
</span></span><span style=display:flex><span>            .try_collect()
</span></span><span style=display:flex><span>            .with_context(<span style=color:#f92672>||</span> format!(<span style=color:#e6db74>&#34;Tried to create a cipher from a string&#34;</span>))<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Check the length of the provided string, we need exactly 26 characters
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>match</span> s.len() {
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>0</span><span style=color:#f92672>..=</span><span style=color:#ae81ff>25</span> <span style=color:#f92672>=&gt;</span> Err(bruh<span style=color:#f92672>!</span>(CipherError::TooFew(s.len()))),
</span></span><span style=display:flex><span>            <span style=color:#ae81ff>26</span> <span style=color:#f92672>=&gt;</span> Cipher::try_from(res), <span style=color:#75715e>// Try to construct Cipher from Vec of Characters
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            _ <span style=color:#f92672>=&gt;</span> Err(bruh<span style=color:#f92672>!</span>(CipherError::TooMany(s.len()))),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> TryFrom<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>Character<span style=color:#f92672>&gt;&gt;</span> <span style=color:#66d9ef>for</span> Cipher {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Error</span> <span style=color:#f92672>=</span> Bruh;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_from</span>(value: Vec<span style=color:#f92672>&lt;</span>Character<span style=color:#f92672>&gt;</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Self, Self::Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Remove duplicates from provided Vector
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> res <span style=color:#f92672>=</span> value.iter().unique().count();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> res {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If we get 26 unique Characters, we can start building our Cipher
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// We iterate through chars A-Z then convert them into Character newtypes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// We use the current value of the iterator to generate our mapping
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#ae81ff>26</span> <span style=color:#f92672>=&gt;</span> (<span style=color:#e6db74>&#39;A&#39;</span><span style=color:#f92672>..=</span><span style=color:#e6db74>&#39;Z&#39;</span>)
</span></span><span style=display:flex><span>                .into_iter()
</span></span><span style=display:flex><span>                .map(<span style=color:#f92672>|</span>c<span style=color:#f92672>|</span> Character::try_from(c).unwrap())
</span></span><span style=display:flex><span>                .enumerate()
</span></span><span style=display:flex><span>                .fold(Ok(Cipher::new()), <span style=color:#f92672>|</span>acc, (i, next)<span style=color:#f92672>|</span> <span style=color:#66d9ef>match</span> acc {
</span></span><span style=display:flex><span>                    Ok(<span style=color:#66d9ef>mut</span> cipher) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        cipher.<span style=color:#ae81ff>0.</span>insert(next, value[i]); <span style=color:#75715e>// Map next-&gt;value[i]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        cipher.<span style=color:#ae81ff>1.</span>insert(value[i], next); <span style=color:#75715e>// Map value[i]-&gt;next
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        Ok(cipher) <span style=color:#75715e>// Return the valid cipher
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    }
</span></span><span style=display:flex><span>                    Err(_) <span style=color:#f92672>=&gt;</span> unreachable!(),
</span></span><span style=display:flex><span>                }),
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> Err(bruh<span style=color:#f92672>!</span>(CipherError::Unique)),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As you can see the validation rules implemented for Cipher are</p><ul><li>Any string passed must be exactly 26 characters long</li><li>Each string must contain exactly 26 unique characters</li><li>Each string must only contain characters A-Z</li></ul><h3 id=the-character-and-position-newtypes>The Character and Position newtypes<a href=#the-character-and-position-newtypes class=hanchor arialabel=Anchor>&#8983;</a></h3><h4 id=whats-a-newtype>What&rsquo;s a newtype?<a href=#whats-a-newtype class=hanchor arialabel=Anchor>&#8983;</a></h4><p><strong>In Gundam:</strong> <em>A newtype is an evolved species of humans that have adapted to life in space</em><br><strong>In Programming:</strong> <em>A newtype is a type declared from the definition of an existing type</em></p><p>In the context of programming, what does this really mean?</p><p>Our language gives us primitive types that we can use to compose data structures. These primitives typically include booleans (true and false), numerical types (integers, floats), string slices and probably a few i&rsquo;m forgetting. Let&rsquo;s say that I want to represent a distance as a floating point decimal. Let&rsquo;s say kilometers and meters. I might go about it in this way:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> kilometers: <span style=color:#66d9ef>f64</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> meters: <span style=color:#66d9ef>f64</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>;
</span></span></code></pre></div><p>Can you see the problem? <code>kilometers</code> and <code>meters</code> are both the same type! That means that adding them together is perfectly valid! Also since they&rsquo;re both <code>f64</code>&rsquo;s they can both be initialized as negative. We don&rsquo;t want negative distances, that&rsquo;s impossible! In the newtype pattern what we would do instead is wrap each of our scalars in a <em>named tuple</em> Then impose validation rules inside functions that construct this type.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Kilometers</span>(<span style=color:#66d9ef>f64</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Meters</span>(<span style=color:#66d9ef>f64</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Use your imagination for the constructors
</span></span></span><span style=display:flex><span><span style=color:#75715e>// This tangent is long enough
</span></span></span></code></pre></div><p>We could also implement the arithmetic operators between these types, allowing us to add, subtract, divide and multiply variables of these types and get results that we expect! Keep in mind that the newtype pattern is much more than simple <em>type aliasing</em> It&rsquo;s essentially a named tuple!</p><h4 id=rant-over>Rant over<a href=#rant-over class=hanchor arialabel=Anchor>&#8983;</a></h4><p>In libenigma I defined three newtypes; one of which i&rsquo;ve already explained. The remaining newtypes are Character and Position.
Character is used throughout the project while Position is used exclusively inside the Rotor Struct</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Character</span>(<span style=color:#66d9ef>char</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Implementing this trait allows us to use it as a key in NoHash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>impl</span> IsEnabled <span style=color:#66d9ef>for</span> Character {} 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(PartialEq, Eq, Clone, Copy, Debug, Hash, PartialOrd)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Position</span>(<span style=color:#66d9ef>u8</span>);
</span></span></code></pre></div><p>The constructor for Character ensures that the internal char is only characters between &lsquo;A&rsquo; and &lsquo;Z&rsquo;. It does this using a match statement. If the character matches to the range match arm &lsquo;A&rsquo;..=&lsquo;Z&rsquo; it is allowed through, otherwise it returns an error type with the original char wrapped inside (this is important so that we don&rsquo;t lose symbols, or non alphabetic characters). The constructor for Position is virtually identical, so i&rsquo;ll omit it</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> TryFrom<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Character {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Error</span> <span style=color:#f92672>=</span> ParsingError;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_from</span>(value: <span style=color:#66d9ef>char</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Self, Self::Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> value_uppercase <span style=color:#f92672>=</span> value.to_ascii_uppercase(); <span style=color:#75715e>// Convert the char to uppercase
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>match</span> value_uppercase {
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#39;A&#39;</span><span style=color:#f92672>..=</span><span style=color:#e6db74>&#39;Z&#39;</span> <span style=color:#f92672>=&gt;</span> Ok(Character(value_uppercase)),
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> Err(ParsingError::Charset(value)),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=the-rotor-struct>The Rotor Struct<a href=#the-rotor-struct class=hanchor arialabel=Anchor>&#8983;</a></h3><p>The rotor struct contains the following fields</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Rotor</span> {
</span></span><span style=display:flex><span>    position: <span style=color:#a6e22e>Position</span>,
</span></span><span style=display:flex><span>    cipher: <span style=color:#a6e22e>Cipher</span>,
</span></span><span style=display:flex><span>    notches: <span style=color:#a6e22e>Notches</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// I lied, there&#39;s more than three newtypes, but this one isn&#39;t public
</span></span></span><span style=display:flex><span><span style=color:#75715e>// I should rather say that there&#39;s  three publicly exposed newtypes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#[derive(Hash, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Notches</span>(Vec<span style=color:#f92672>&lt;</span>Position<span style=color:#f92672>&gt;</span>); 
</span></span></code></pre></div><p>Each Cipher contains two functions, <em>encode</em> and <em>decode</em>. We use these methods to share the encoding logic between each component of the enigma machine.
The logic in these functions is deceptively simple, what you don&rsquo;t see is a whole mess of well-tested overloaded operators</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>encode_at</span>(<span style=color:#f92672>&amp;</span>self, c: <span style=color:#a6e22e>Character</span>, n: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#a6e22e>Character</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> offset: <span style=color:#a6e22e>Position</span> <span style=color:#f92672>=</span> self.position <span style=color:#f92672>+</span> n;
</span></span><span style=display:flex><span>        self.cipher.encode(c <span style=color:#f92672>+</span> offset)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>decode_at</span>(<span style=color:#f92672>&amp;</span>self, c: <span style=color:#a6e22e>Character</span>, n: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#a6e22e>Character</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> offset: <span style=color:#a6e22e>Position</span> <span style=color:#f92672>=</span> self.position <span style=color:#f92672>+</span> n;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> dec <span style=color:#f92672>=</span> self.cipher.decode(c);
</span></span><span style=display:flex><span>        dec <span style=color:#f92672>-</span> offset
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>There&rsquo;s actually a lot to unpack here. These functions gave me a lot of trouble when it came around to integration testing because for the life of me I coulnd&rsquo;t figure out why i could encode a character through a rotor, then decode the ciphertext back through the rotor and i&rsquo;d get a different character from what I started out with. THe problem was <em>where</em> I was doing the addidion of the rotor&rsquo;s offset to the encoding. In encode_at I was adding the offset to the character before encoding the character while originally I was doing the same in decode_at. However, it took some thinking through and talking to a rubber duck to reason around why this was causing me problems. Unfortunately I lack the language skills to explain why</p><p>Also the reason these functions are called encode_at instead of simply encode is that here we&rsquo;re encoding the character given a certain number of rotations of the current rotor. This is absolutely critical for multithreading later as we don&rsquo;t have to rely on internal state, meaning that we can encode characters <em>out of order</em> but we have to be able to predict how many times the current rotor has advanced. That&rsquo;s where this function comes in:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#e6db74>/// given n revolutions of the current rotor, how many times will the next rotor in the sequence advance?
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_num_advances</span>(<span style=color:#f92672>&amp;</span>self, n: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#66d9ef>usize</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> r <span style=color:#f92672>=</span> n <span style=color:#f92672>/</span> <span style=color:#ae81ff>26</span>; <span style=color:#75715e>// Number of full revolutions
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> notches_left <span style=color:#f92672>=</span> self
</span></span><span style=display:flex><span>            .notches
</span></span><span style=display:flex><span>            .<span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .filter(<span style=color:#f92672>|</span>notch<span style=color:#f92672>|</span> self.position <span style=color:#f92672>&lt;=</span> <span style=color:#f92672>**</span>notch)
</span></span><span style=display:flex><span>            .count(); <span style=color:#75715e>// How many notches are left in the first rotation of the rotor, given the inital position of the rotor
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> final_position <span style=color:#f92672>=</span> Position::try_from((n <span style=color:#f92672>%</span> <span style=color:#ae81ff>26</span>) <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>u8</span>).unwrap(); <span style=color:#75715e>// gets the position of the rotor after n advances
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> notches_past <span style=color:#f92672>=</span> self
</span></span><span style=display:flex><span>            .notches
</span></span><span style=display:flex><span>            .<span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>            .iter()
</span></span><span style=display:flex><span>            .filter(<span style=color:#f92672>|</span>notch<span style=color:#f92672>|</span> final_position <span style=color:#f92672>&gt;</span> <span style=color:#f92672>**</span>notch)
</span></span><span style=display:flex><span>            .count(); <span style=color:#75715e>// How many notches have we passed in the current partial revolution
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Multiply full rotations by the number of notches and add the number of notches left in the first rotation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> result <span style=color:#f92672>=</span> (r <span style=color:#f92672>*</span> self.notches.<span style=color:#ae81ff>0.</span>len()) <span style=color:#f92672>+</span> notches_left; 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we&#39;ve completed at least one rotation, add notches_past
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> r <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            result <span style=color:#f92672>=</span> result <span style=color:#f92672>+</span> notches_past
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        result
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>This function says &ldquo;Given how many times this rotor has advanced, how many times will it advance the next rotor?&rdquo;. We can use this information to pass to the next rotor in the sequence to get the position of every rotor given <em>n</em> characters encoded.</p><p>Also, I don&rsquo;t allow construction of Rotors directly, I generate them based off of the reference table from wikipedia, Meaning that assuming that my unit tests are correct and wikipedia&rsquo;s information is correct, you could decipher real world enigma transmissions using this library. Neat!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[derive(
</span></span></span><span style=display:flex><span><span style=color:#75715e>    EnumString, EnumIter, Hash, PartialEq, Eq, Clone, Copy, Display, Debug, Serialize, Deserialize,
</span></span></span><span style=display:flex><span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Rotors</span> {
</span></span><span style=display:flex><span>    I,
</span></span><span style=display:flex><span>    II,
</span></span><span style=display:flex><span>    III,
</span></span><span style=display:flex><span>    IV,
</span></span><span style=display:flex><span>    V,
</span></span><span style=display:flex><span>    VI,
</span></span><span style=display:flex><span>    VII,
</span></span><span style=display:flex><span>    VIII,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> TryFrom<span style=color:#f92672>&lt;</span>(Rotors, <span style=color:#66d9ef>char</span>)<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> Rotor {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Error</span> <span style=color:#f92672>=</span> Bruh;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>try_from</span>((variant, position): (Rotors, <span style=color:#66d9ef>char</span>)) -&gt; Result<span style=color:#f92672>&lt;</span>Self, Self::Error<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> variant {
</span></span><span style=display:flex><span>            Rotors::I <span style=color:#f92672>=&gt;</span> Rotor::new(<span style=color:#e6db74>&#34;EKMFLGDQVZNTOWYHXUSPAIBRCJ&#34;</span>, <span style=color:#f92672>&amp;</span>[<span style=color:#e6db74>&#39;Q&#39;</span>], position),
</span></span><span style=display:flex><span>            Rotors::II <span style=color:#f92672>=&gt;</span> Rotor::new(<span style=color:#e6db74>&#34;AJDKSIRUXBLHWTMCQGZNPYFVOE&#34;</span>, <span style=color:#f92672>&amp;</span>[<span style=color:#e6db74>&#39;E&#39;</span>], position),
</span></span><span style=display:flex><span>            Rotors::III <span style=color:#f92672>=&gt;</span> Rotor::new(<span style=color:#e6db74>&#34;BDFHJLCPRTXVZNYEIWGAKMUSQO&#34;</span>, <span style=color:#f92672>&amp;</span>[<span style=color:#e6db74>&#39;V&#39;</span>], position),
</span></span><span style=display:flex><span>            Rotors::IV <span style=color:#f92672>=&gt;</span> Rotor::new(<span style=color:#e6db74>&#34;ESOVPZJAYQUIRHXLNFTGKDCMWB&#34;</span>, <span style=color:#f92672>&amp;</span>[<span style=color:#e6db74>&#39;J&#39;</span>], position),
</span></span><span style=display:flex><span>            Rotors::V <span style=color:#f92672>=&gt;</span> Rotor::new(<span style=color:#e6db74>&#34;VZBRGITYUPSDNHLXAWMJQOFECK&#34;</span>, <span style=color:#f92672>&amp;</span>[<span style=color:#e6db74>&#39;Z&#39;</span>], position),
</span></span><span style=display:flex><span>            Rotors::VI <span style=color:#f92672>=&gt;</span> Rotor::new(<span style=color:#e6db74>&#34;JPGVOUMFYQBENHZRDKASXLICTW&#34;</span>, <span style=color:#f92672>&amp;</span>[<span style=color:#e6db74>&#39;Z&#39;</span>, <span style=color:#e6db74>&#39;M&#39;</span>], position),
</span></span><span style=display:flex><span>            Rotors::VII <span style=color:#f92672>=&gt;</span> Rotor::new(<span style=color:#e6db74>&#34;NZJHGRCXMYSWBOUFAIVLPEKQDT&#34;</span>, <span style=color:#f92672>&amp;</span>[<span style=color:#e6db74>&#39;Z&#39;</span>, <span style=color:#e6db74>&#39;M&#39;</span>], position),
</span></span><span style=display:flex><span>            Rotors::VIII <span style=color:#f92672>=&gt;</span> Rotor::new(<span style=color:#e6db74>&#34;FKQHTLXOCBJSPDZRAMEWNIUYGV&#34;</span>, <span style=color:#f92672>&amp;</span>[<span style=color:#e6db74>&#39;Z&#39;</span>, <span style=color:#e6db74>&#39;M&#39;</span>], position),
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=the-reflector>The Reflector<a href=#the-reflector class=hanchor arialabel=Anchor>&#8983;</a></h3><p>This component was the simplest because It requires little configuration on the part of the user, Simply pick a reflector variant and you&rsquo;re good to go.
The construction of the reflector is virtually identical to Rotor, so i&rsquo;ll omit it but keep in mind that we don&rsquo;t have to keep track of the position of the reflector because it&rsquo;s not a moving part. Otherwise The reflector works exactly the same. However, the reflector has a special property that it only accepts connections on one side. Meaning that insead of being able to encode then decode a character to get your original character back, you are able to encode, the <em>encode again</em> to get your original character back. This is the reason why you can decode enigma messages given the same configuration.</p><p>Also the encode function is very nice to look at</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Encode <span style=color:#66d9ef>for</span> Reflector {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Encodes a given char through the reflector.
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// Given the properties of the reflector, if the output of this function was fed through this function again,
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#e6db74>/// you would get back the original char
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>encode</span>(<span style=color:#f92672>&amp;</span>self, c: <span style=color:#a6e22e>Character</span>) -&gt; <span style=color:#a6e22e>Character</span> {
</span></span><span style=display:flex><span>        self.cipher.encode(c)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=the-plugboard>The plugboard<a href=#the-plugboard class=hanchor arialabel=Anchor>&#8983;</a></h3><p>In the enigma machine you are given ten plugs, You are given the choice to map any character to any other character. You may not map multiple characters to the same character(because you physically could not on the original machine) and you can use no more than 10 plugs(because the machine only came with 10) you also don&rsquo;t have to use all of the plugs. Or any for that matter. Given the complexity of this component (and the fact i had to write an interface to generate one from the command line) I&rsquo;ll try to keep this short</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Plugboard</span> {
</span></span><span style=display:flex><span>    cipher: <span style=color:#a6e22e>Cipher</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Internally the Plugboard contains only a cipher. Most of the logic in this module is geared towards <em>constructing</em> a valid cipher string given user input
Basically we take a vec of tuples <code>(Character,Character)</code> and validate them against the aforementioned invariants then create our cipher string and use it as our internal cipher. Likewise, the encode function is very simple here. We simply pass the given Character to the internal Cipher newtype. Oh also I should mention that like the Reflector, The mappings in the plugboard go both ways.</p><h3 id=putting-it-together-enigma>Putting it together: Enigma<a href=#putting-it-together-enigma class=hanchor arialabel=Anchor>&#8983;</a></h3><p>As I said before, each component in the engima machine acts as a substitution cipher. However, the order in which you apply these ciphers is important</p><ul><li>A Key is pressed</li><li>That character is encoded through the plugboard</li><li>The ciphertext from the plugboard is then encoded through each individual rotor</li><li>The output from the rotor mechanism is encoded through the reflector</li><li>The output from the reflector is fed <em>backwards</em> through the rotor mechanism</li><li>The ciphertext makes one final pass through the plugboard</li><li>Then we get the final character</li></ul><p>Here&rsquo;s what the code looks like for a single character:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>encode_at</span>(<span style=color:#f92672>&amp;</span>self, c: <span style=color:#a6e22e>Character</span>, n: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#a6e22e>Character</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> plugboard_enc <span style=color:#f92672>=</span> self.plugboard.encode(c);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> rotor_enc <span style=color:#f92672>=</span> self.rotors.encode_at(plugboard_enc, n);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> reflector_enc <span style=color:#f92672>=</span> self.reflector.encode(rotor_enc);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> rotor_dec <span style=color:#f92672>=</span> self.rotors.decode_at(reflector_enc, n);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> plugboard_dec <span style=color:#f92672>=</span> self.plugboard.decode(rotor_dec);
</span></span><span style=display:flex><span>        plugboard_dec
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Oh my, I lied again! I actually declared <em>four</em> public newtypes. Essentially here I abstract away feeding the output of each rotor into the next into a single operation</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>RotorConfig</span>(Vec<span style=color:#f92672>&lt;</span>Rotor<span style=color:#f92672>&gt;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> RotorConfig {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>encode_at</span>(<span style=color:#f92672>&amp;</span>self, c: <span style=color:#a6e22e>Character</span>, n: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#a6e22e>Character</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> encode_first_rotor <span style=color:#f92672>=</span> self.<span style=color:#ae81ff>0</span>[<span style=color:#ae81ff>0</span>].encode_at(c, n);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> n <span style=color:#f92672>=</span> self.<span style=color:#ae81ff>0</span>[<span style=color:#ae81ff>0</span>].get_num_advances(n);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> encode_second_rotor <span style=color:#f92672>=</span> self.<span style=color:#ae81ff>0</span>[<span style=color:#ae81ff>1</span>].encode_at(encode_first_rotor, n);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> n <span style=color:#f92672>=</span> self.<span style=color:#ae81ff>0</span>[<span style=color:#ae81ff>1</span>].get_num_advances(n);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> encode_third_rotor <span style=color:#f92672>=</span> self.<span style=color:#ae81ff>0</span>[<span style=color:#ae81ff>2</span>].encode_at(encode_second_rotor, n);
</span></span><span style=display:flex><span>        encode_third_rotor
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>decode_at</span>(<span style=color:#f92672>&amp;</span>self, c: <span style=color:#a6e22e>Character</span>, n: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#a6e22e>Character</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> r1_advances <span style=color:#f92672>=</span> n;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> r2_advances <span style=color:#f92672>=</span> self.<span style=color:#ae81ff>0</span>[<span style=color:#ae81ff>0</span>].get_num_advances(n);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> r3_advances <span style=color:#f92672>=</span> self.<span style=color:#ae81ff>0</span>[<span style=color:#ae81ff>1</span>].get_num_advances(r2_advances);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> decode_third_rotor <span style=color:#f92672>=</span> self.<span style=color:#ae81ff>0</span>[<span style=color:#ae81ff>2</span>].decode_at(c, r3_advances);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> decode_second_rotor <span style=color:#f92672>=</span> self.<span style=color:#ae81ff>0</span>[<span style=color:#ae81ff>1</span>].decode_at(decode_third_rotor, r2_advances);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> decode_first_rotor <span style=color:#f92672>=</span> self.<span style=color:#ae81ff>0</span>[<span style=color:#ae81ff>0</span>].decode_at(decode_second_rotor, r1_advances);
</span></span><span style=display:flex><span>        decode_first_rotor
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s not terribly useful to only be able to encode one character at a time, So I needed to write a function that could encode an entire String</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>encode</span>(<span style=color:#f92672>&amp;</span>self, s: <span style=color:#66d9ef>&amp;</span>String) -&gt; String {
</span></span><span style=display:flex><span>        s.par_char_indices()
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>(i, c)<span style=color:#f92672>|</span> (i, Character::try_from(c)))
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>(n, c)<span style=color:#f92672>|</span> <span style=color:#66d9ef>match</span> c {
</span></span><span style=display:flex><span>                Ok(plain) <span style=color:#f92672>=&gt;</span> self.encode_at(plain, n).into(), <span style=color:#75715e>// If character is &#39;A&#39;-&#39;Z&#39;, encode it
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                Err(e) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>match</span> e {
</span></span><span style=display:flex><span>                    ParsingError::Charset(non_alphabetic) <span style=color:#f92672>=&gt;</span> non_alphabetic, <span style=color:#75715e>// Otherwise, simply return the original character
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    _ <span style=color:#f92672>=&gt;</span> unreachable!(),
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .collect()
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>There&rsquo;s actually something special going on here. Can you see it? I&rsquo;m multithreading it! Using the excellent <code>rayon</code> crate, I&rsquo;m able to generate a <em>parallel</em> iterator from this string, allowing me to build my logic in the same manner as if I was writing a single threaded version!!!</p><h2 id=the-benchmarks>The Benchmarks:<a href=#the-benchmarks class=hanchor arialabel=Anchor>&#8983;</a></h2><p>The benchmark generates a string of random characters (All A-Z) given length <em>n</em>
I&rsquo;ve generated benchmarks for strings of the following lengths</p><ul><li>1 thousand</li><li>10 thousand</li><li>100 thousand</li><li>1 million</li><li>10 million</li><li>100 million</li></ul><p>Here&rsquo;s the results</p><pre tabindex=0><code>     Running benches\perf.rs (target\release\deps\perf-f5e366b5f8262b43.exe)
1k                      time:   [215.39 µs 216.71 µs 218.12 µs]
Found 5 outliers among 100 measurements (5.00%)
  5 (5.00%) high mild

10k                     time:   [591.08 µs 594.62 µs 598.26 µs]
Found 4 outliers among 100 measurements (4.00%)
  1 (1.00%) low mild
  3 (3.00%) high mild

Benchmarking 100k: Warming up for 3.0000 s
Warning: Unable to complete 100 samples in 5.0s. You may wish to increase target time to 9.6s, enable flat sampling, or reduce sample count to 50.
100k                    time:   [1.8469 ms 1.8593 ms 1.8730 ms]
Found 3 outliers among 100 measurements (3.00%)
  3 (3.00%) high mild

1m                      time:   [9.3270 ms 9.4011 ms 9.4863 ms]
Found 1 outliers among 100 measurements (1.00%)
  1 (1.00%) high severe

Benchmarking 10m: Warming up for 3.0000 s
Warning: Unable to complete 100 samples in 5.0s. You may wish to increase target time to 7.9s, or reduce sample count to 60.
10m                     time:   [79.100 ms 79.525 ms 79.963 ms]
Found 4 outliers among 100 measurements (4.00%)
  4 (4.00%) high mild

Benchmarking 100m: Warming up for 3.0000 s
Warning: Unable to complete 100 samples in 5.0s. You may wish to increase target time to 78.5s, or reduce sample count to 10.
100m                    time:   [768.39 ms 771.83 ms 775.81 ms]
Found 5 outliers among 100 measurements (5.00%)
  2 (2.00%) high mild
  3 (3.00%) high severe
</code></pre><p>That&rsquo;s right, We can encode 100 Million characters in less than a second, Or more practically, 1 million characters in around 9 Milliseconds. To put that in perspective, Herman Melville&rsquo;s <em>Moby Dick</em> utf-8 version from project gutenburg is a little over a megabyte. If we assume that each character takes up between 1 and 4 bytes per character (and let&rsquo;s face it it&rsquo;s mostly ascii) that gives us approximately a little over a million characters. We could encode the entirety of <strong>Moby Dick</strong> In <em><strong>Thousandths</strong></em> of a second. How about Crime and Punishment? War and peace?</p><ul><li>Crime and Punishment: 1.1MB</li><li>War and Peace: 3.2 MB<br>Not even Russian Literature stands a chance!</li></ul></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><span class="button next"><a href=https://thatnerduknow.github.io/posts/typescript-is-magic/><span class=button__text>Typescript Is Magic</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2022 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://thatnerduknow.github.io/assets/main.js></script>
<script src=https://thatnerduknow.github.io/assets/prism.js></script></div></body></html>